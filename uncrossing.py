#!/usr/bin/env python2
from posets import transClose
from sys import argv
from math import log

class uncrossing:

	#Throughout pairings are encoded as lists of numbers, each number encodes
	#a pair as two bits set. For example the pairing {{1,3},{2,4}} is encoded
	#as [2**0+2**2,2**1+2**3]=[5,10]

	#converts the pairing given in the input into the internal format described above
	def readPairing(input):
		input = input.split(',')
		t = []
		for i in range(0,len(input)//2):
			t.append(1<<(int(input[i<<1])-1)|1<<(int(input[(i<<1)+1])-1))
		return sorted(t)

	#swaps all occurrences of i and j in p
	def swap(p,i,j):
		ret = []
		for arc in p:
			if (arc&(1<<i))>>i != (arc&(1<<j))>>j: #arc contains one of i and j
				ret.append(arc ^ ((1<<i)|(1<<j))) #swap i and j in the arc
			else: #arc contains both i and j or neither so don't swap i and j
				ret.append(arc)
		return sorted(ret)


	#returns the crossing number for p
	def c(p):
		ret = 0
		for i in range(0,len(p)):
			xi = bin(p[i])[::-1]
			Ni = xi.find('1')
			Ei = xi.rfind('1')
			for j in range(i+1,len	(p)):
				xj = bin(p[j])[::-1]
				Nj = xj.find('1')
				Ej = xj.rfind('1')
				if (Ni - Nj > 0) == (Ei - Ej > 0) == (Nj - Ei > 0): ret += 1

		return ret

	#computes the lower interval generated by the given pairing via
	#returns a tuple (P,ranks,M) which is the list of elements, the rank list and the cover matrix
	def lowerOrderIdeal(t):
		if uncrossing.c(t)==0: return [t],[[1],[0]],[[0,-1],[1,0]]

		P=[t]
		ranks = [[0]] #this is built up backwards for convenience and reversed before returning
		M=[[0]]

		num = 1 #index in to P of next element to add
		level = [t] #list of current rank to expand in next step
		leveli = [0] #indices in to P of the elements of level
		newLevel = [] #we build level for the next step during the current step here
		newLeveli = [] #indices in to P for the next step
		newRank = [] #the new rank indices to add
		while len(level) > 0:
			for i in range(0,(len(t)<<1)-1): #iterate over all pairs we can uncross
				for j in range(i+1,len(t)<<1):
					for k in range(0,len(level)): #do the uncross
						temp = uncrossing.swap(level[k],i,j)
						c_temp = uncrossing.c(temp)
						if c_temp != uncrossing.c(level[k])-1: continue
						if temp in P:
							M[P.index(temp)][leveli[k]]=1
							continue
						P.append(temp)
						newRank.append(num)
						if c_temp > 0: #if not minimal continue uncrossing
							newLevel.append(temp)
							newLeveli.append(num)
						num+= 1

						for x in M: x.append(0)
						M.append([0 for x in range(0,len(M[0]))])
						M[-1][leveli[k]]=1

			level = newLevel
			newLevel = []
			leveli = newLeveli
			newLeveli = []
			ranks.append(newRank)
			newRank = []

		ranks.reverse()
		ranks=[[len(M)]]+ranks
		for r in M: r.append(-1)
		M.append([0]+[1 for i in range(0,len(P))])
		return P,ranks,M

	def __init__(this,vars):
		this.vars=vars
		try:
			this.t=uncrossing.readPairing(this.vars.argv[1])
		except:
			print("Error reading pairing")
			exit()
		this.P,this.lengths,this.M=uncrossing.lowerOrderIdeal(this.t)
		transClose(this.M)

		this.n=len(this.t)
		this.maxrksize=max([len(r) for r in this.lengths])

		this.bend=this.vars.get_arg('bend','0.5')
		this.ranked=True

	def is_unranked(this):
		return 0

	def loc_x(this,i):
		#\zerohat is last and \onehat is first
		if i==0 or i==len(this.P): return '0'
		rk=uncrossing.c(this.P[i])+1
		rkwidth=log(float(len(this.lengths[rk])))/log(this.maxrksize)*float(this.vars.width)
		index=this.lengths[rk].index(i)
		return str((float(index)/float(len(this.lengths[rk])-1))*rkwidth - (rkwidth/2.0))

	def loc_y(this,i):
		if i==len(this.P): return '0'
		if i==0: return str(this.vars.height)
		delta=float(this.vars.height)/float(len(this.lengths)-2)
		return str(uncrossing.c(this.P[i])*delta+delta/2.0)


	def nodeLabel(this,i):
		if i==len(this.P): return "\\scalebox{2}{$\widehat{0}$}"
		ret=["\\begin{tikzpicture}[scale="+this.vars.nodetikzscale+"]\n\\begin{scope}\n\t\\medial\n"]
		for arc in [[float(i) for i in range(0,this.n<<1) if (1<<i)&x!=0] for x in this.P[i]]:
			ret.append('\t\draw('+str(int(arc[0]+1))+')..controls+(')
			ret.append(str((arc[0])*(-360.0)/(this.n<<1)-90))
			ret.append(':\\r*'+this.bend+')and+(')
			ret.append(str((arc[1])*(-360.0)/(this.n<<1)-90))
			ret.append(':\\r*'+this.bend+')..('+str(int(arc[1]+1))+');\n')
		return ''.join(ret+["\\end{scope}\\end{tikzpicture}"])

	def nodeName(this,i):
		if i==len(this.P): return 'z'
		p=this.P[i]
		n=len(p)
		return ''.join([str(j+1) for k in range(0,n) for j in range(0,n<<1) if (1<<j)&p[k]!=0])

	def extra_packages(this):
		return "\\def\\r{1}\n\\def\\n{"+str(this.n<<1)+"}\n\\newcommand{\\medial}{\n\\draw circle (\\r);\n\\foreach\\i in{1,...,\\n}\n\t{\n\t\\pgfmathsetmacro{\\j}{-90-360/\\n*(\\i-1)}\n\t\\fill (\\j:-\\r) circle (2pt) node [anchor=\\j] {$\\i$};\n\t\\coordinate (\\i) at (\\j:-\\r);\n\t}\n}"

	def less(this,i,j):
		return this.M[i][j]==1
